PopR
{
  [ :r | OrderedCollection 
        with: (self instr: 'lwz' bind: r bind: 18 bind: 0)
        with: (self instr: 'addi' bind: 18 bind: 18 bind: -4)]
}

    
RREqualP
{
  [ :rA :rB :to | OrderedCollection 
        with: (self instr: 'subf' bind: to bind: rA bind: rB)
        with: (self instr: 'cntlzw' bind: to bind: to)
        with: (self instr: 'rlwinm' bind: to bind: to bind: 27 bind: 31 bind: 31)]
}
   

PushR
{
  [ :r | OrderedCollection 
        with: (self instr: 'addi' bind: 18 bind: 18 bind: 4)
        with: (self instr: 'stw' bind: r bind: 18 bind: 0)   ]
}

    
PushRIndirect
{
  [ :r :offset | OrderedCollection 
        with: (self instr: 'addi' bind: 18 bind: 18 bind: 4)
        with: (self instr: 'lwz' bind: 20 bind: r bind: offset)   
        with: (self instr: 'stw' bind: 20 bind: 18 bind: 0)   ]
}

    
NoteIndex
{
  [ :i | OrderedCollection 
        with: (self instr: 'addi' bind: 19 bind: 0 bind: i)]
}

   
LoadByteIndexed
{
  [ :rDest :rBase :offset | OrderedCollection 
        with: (self instr: 'lbz' bind: rDest bind: rBase bind: offset)]
}


LoadIndexed
{
  [ :rDest :rBase :offset | OrderedCollection 
        with: (self instr: 'lwz' bind: rDest bind: rBase bind: offset)]
}


LoadIndexedRor0
{
  [ :rDest :rBase :rOffset | OrderedCollection 
        with: (self instr: 'lwzx' bind: rDest bind: rOffset bind: rBase)]
}


AddRRConst
{
  [ :from :to :const | OrderedCollection 
        with: (self instr: 'addi' bind: to bind: from bind: const)]
}


MulRRConst
{
  [ :from :to :const | OrderedCollection 
        with: (self instr: 'mulli' bind: to bind: from bind: const)]
}


MulRR
{
  [ :rDst :a :b | OrderedCollection 
        with: (self instr: 'mullw' bind: rDst bind: a bind: b)]
}


AddRR
{
  [ :rDest :rSrcA :rSrcB | OrderedCollection 
        with: (self instr: 'add' bind: rDest bind: rSrcA bind: rSrcB)]
}


AddRRConst32
{
  [ :from :to :const | OrderedCollection 
        with: (self instr: 'addis' bind: to bind: from bind:
            ((const bitAnd: 16r8000) = 0 ifTrue: [const >> 16] ifFalse: [const >> 16 + 1]))
        with: (self instr: 'addi' bind: to bind: to bind: (const bitAnd: 16rFFFF))]
}


DivRR
{
  [ :rT :rA :rB | OrderedCollection 
        with: (self instr: 'divw' bind: rT bind: rA bind: rB)]
}


RemRR
{
  [ :rT :rA :rB | OrderedCollection 
        with: (self instr: 'divw' bind: 20 bind: rA bind: rB)
        with: (self instr: 'mullw' bind: 20 bind: 20 bind: rB)
        with: (self instr: 'subf' bind: rT bind: 20 bind: rA)]
}


SubRR
{
  [ :rDest :rSrcA :rSrcB | OrderedCollection 
        with: (self instr: 'subf' bind: rDest bind: rSrcA bind: rSrcB)]
}


AndRR
{
  [ :rDest :rSrcA :rSrcB | OrderedCollection 
        with: (self instr: 'ande' bind: rDest bind: rSrcA bind: rSrcB)]
}


MovRR
{
  [ :from :to | OrderedCollection 
        with: (self instr: 'ori' bind: from bind: to bind: 0)]
}


MovRLR
{
  [ :rSrc | OrderedCollection 
        with: (self instr: 'mtspr' bind: rSrc bind: 2r0100000000)]
}


MovLRR
{
  [ :rDest | OrderedCollection 
        with: (self instr: 'mfspr' bind: rDest bind: 2r0100000000)]
}


StoreIndexed
{
  [ :rSrc :rBase :off | OrderedCollection 
        with: (self instr: 'stw' bind: rSrc bind: rBase bind: off)]
}


StoreByteIndexed
{
  [ :rSrc :rBase :off | OrderedCollection 
        with: (self instr: 'stb' bind: rSrc bind: rBase bind: off)]
}


StoreIndexedRor0
{
  [ :rValue :rBase :rOffset | OrderedCollection 
        with: (self instr: 'stwx' bind: rValue bind: rOffset bind: rBase)]
}

ShiftLeft2
{
  [ :rSrc :rDest | OrderedCollection 
        with: (self instr: 'rlwinm' bind: rSrc bind: rDest bind: 2 bind: 0 bind: 29)]
}


LoadImm32
{
  [ :r :int | OrderedCollection 
        with: (self instr: 'addis' bind: r bind: 0 bind: ((int bitShift: -16) decodeSignedWidth: 16))
        with: (self instr: 'ori'  bind: r bind: r bind: (int bitAnd: 16rFFFF))]
}


JumpImm32
{
  [ :int | OrderedCollection 
        with: (self instr: 'addis' bind: 20 bind: 0 bind: int >> 16)
        with: (self instr: 'ori'  bind: 20 bind: 20 bind: (int bitAnd: 16rFFFF))
        with: (self instr: 'mtspr' bind: 20 bind: 2r0100100000)
        with: (self instr: 'bcctr' bind: 2r11111 bind: 0 bind: 0) ]
}


JumpImm32IfNE
{
  [ :ra :rb :addr | OrderedCollection 
        with: (self instr: 'cmp' bind: 0 bind: 0 bind: ra bind: rb)
        with: (self instr: 'addis' bind: 20 bind: 0 bind: addr >> 16)
        with: (self instr: 'ori'  bind: 20 bind: 20 bind: (addr bitAnd: 16rFFFF))
        with: (self instr: 'mtspr' bind: 20 bind: 2r0100100000)
        with: (self instr: 'bcctr' bind: 4 bind: 2 bind: 0) ]
}

JumpRelIfLE
{
  [ :ra :rb :offset | OrderedCollection 
        with: (self instr: 'cmp' bind: 0 bind: 0 bind: ra bind: rb)
        with: (self instr: 'bc' bind: 4 bind: 0 bind: 1 bind: offset-1 bind: 0 bind: 0) ]
}

JumpRelIfEQ
{
  [ :ra :rb :offset | OrderedCollection 
        with: (self instr: 'cmp' bind: 0 bind: 0 bind: ra bind: rb)
        with: (self instr: 'bc' bind: 12 bind: 0 bind: 2 bind: offset-1 bind: 0 bind: 0) ]
}


JumpRelIfNE
{
  [ :ra :rb :offset | OrderedCollection 
        with: (self instr: 'cmp' bind: 0 bind: 0 bind: ra bind: rb)
        with: (self instr: 'bc' bind: 4 bind: 0 bind: 2 bind: offset-1 bind: 0 bind: 0) ]
}


JumpRelIfTagNE
{
  [ :rWhereTagIs :compareTo :offset | OrderedCollection
        with: (self instr: 'cmpi' bind: 0 bind: rWhereTagIs bind: compareTo)
        with: (self instr: 'bc' bind: 4 bind: 0 bind: 2 bind: offset-1 bind: 0 bind: 0) ]
}


JumpRifReqI
{
  [ :ra :i :rJump | OrderedCollection 
        with: (self instr: 'addis' bind: 20 bind: 0 bind: i >> 16)
        with: (self instr: 'ori'  bind: 20 bind: 20 bind: (i bitAnd: 16rFFFF))
        with: (self instr: 'cmp' bind: 0 bind: 0 bind: ra bind: 20)
        with: (self instr: 'mtspr' bind: rJump bind: 2r0100100000)
        with: (self instr: 'bcctr' bind: 12 bind: 2 bind: 0) ]
}

JumpImm32andLink
{
  [ :int | OrderedCollection 
        with: (self instr: 'addis' bind: 20 bind: 0 bind: int >> 16)
        with: (self instr: 'ori'  bind: 20 bind: 20 bind: (int bitAnd: 16rFFFF))
        with: (self instr: 'mtspr' bind: 20 bind: 2r0100100000)
        with: (self instr: 'bcctrl' bind: 2r11111 bind: 0 bind: 0) ]
}

JumpRandLink
{
  [ :r | OrderedCollection 
        with: (self instr: 'mtspr' bind: r bind: 2r0100100000)
        with: (self instr: 'bcctrl' bind: 2r11111 bind: 0 bind: 0) ]
}

JumpR
{
  [ :r | OrderedCollection 
        with: (self instr: 'mtspr' bind: r bind: 2r0100100000)
        with: (self instr: 'bcctr' bind: 2r10100 bind: 0 bind: 0) ]
}


JumpRifZ
{
  [ :r | OrderedCollection 
        with: (self instr: 'mtspr' bind: r bind: 2r0100100000)
        with: (self instr: 'bcctr' bind: 2r01100 bind: 2r10110 bind: 0) ]
}


FillSlots
{
  [ :rCount :rBase :immValue | OrderedCollection
        with: (self instr: 'addis' bind: 20 bind: 0   bind: (immValue >> 16 decodeSignedWidth: 16))
        with: (self instr: 'ori'   bind: 20 bind: 20  bind: (immValue bitAnd: 16rFFFF))
        with: (self instr: 'mtspr' bind: rCount bind: 2r0100100000)
        with: (self instr: 'stwu' bind: 20 bind: rBase bind: 4)
        with: (self instr: 'bc' bind: 16 bind: 0 bind: 0 bind: -1 bind: 0 bind: 0) ]
}


SignBit
{
  [ :rSrc :rDst | OrderedCollection 
        with: (self instr: 'rlwinm' bind: rSrc bind: rDst bind: 1 bind: 31 bind: 31) ]
}


EncodeChar
{
  [ :rSrc :rDst | OrderedCollection 
        with: (self instr: 'rlwinm' bind: rSrc bind: rDst bind: 4 bind: 4 bind: 27)
        with: (self instr: 'ori'  bind: rDst bind: rDst bind: 2) ]
}


DecodeChar
{
  [ :rSrc :rDst | OrderedCollection 
        with: (self instr: 'rlwinm' bind: rSrc bind: rDst bind: 28 bind: 4 bind: 31) ]
}


CP2Char
{
  [ :rSrc :rDst | OrderedCollection 
        with: (self instr: 'rlwinm' bind: rSrc bind: rDst bind: 0 bind: 0 bind: 29)
        with: (self instr: 'ori' bind: rDst bind: rDst bind: 2) ]
}


EncodeSI
{
  [ :rSrc :rDst | OrderedCollection 
        with: (self instr: 'rlwinm' bind: rSrc bind: rDst bind: 4 bind: 4 bind: 27)
        with: (self instr: 'ori'  bind: rDst bind: rDst bind: 1) ]
}


DecodeSI
{
  [ :rSrc :rDst | OrderedCollection 
        with: (self instr: 'srawi' bind: rSrc bind: rDst bind: 4) ]
}


SlotSIOffsetToByteOffset
{
  [ :rSrc :rDst | OrderedCollection 
        with: (self instr: 'rlwinm' bind: rSrc bind: rDst bind: 30 bind: 4 bind: 29) ]
}


GetTag
{
  [ :rSrc :rDst | OrderedCollection 
        with: (self instr: 'rlwinm' bind: rSrc bind: rDst bind: 0 bind: 30 bind: 31) ]
}


StripTag
{
  [ :rSrc :rDst | OrderedCollection 
        with: (self instr: 'rlwinm' bind: rSrc bind: rDst bind: 0 bind: 0 bind: 29) ]
}


MarkSuccess
{
  [ OrderedCollection 
        with: (self instr: 'cmp' bind: 2 bind: 0 bind: 0 bind: 0) ]

}


MarkFail
{
  [ OrderedCollection 
        with: (self instr: 'cmp' bind: 2 bind: 0 bind: 16 bind: 17) ]
}


Return
{
  [ OrderedCollection 
        with: (self instr: 'bclr' bind: 16r14 bind: 0 bind: 0) ]
}


ReturnIfEQ
{
  [ :ra :rb | OrderedCollection 
        with: (self instr: 'cmp' bind: 0 bind: 0 bind: ra bind: rb)
        with: (self instr: 'bclr' bind: 12 bind: 2 bind: 0) ]
}


RoundUpTo16
{
  [ :rSrc :rDst | OrderedCollection 
        with: (self instr: 'addi' bind: rDst bind: rSrc bind: 2r1111)
        with: (self instr: 'rlwinm' bind: rDst bind: rDst bind: 0 bind: 0 bind: 27) ]

}


AttachContextTag
{
  [ :r | OrderedCollection 
        with: (self instr: 'ori' bind: r bind: r bind: 2r11)  ]

}


MakeOopHeader
{
  [ :rNumVars :rDst | OrderedCollection 
        with: (self instr: 'rlwinm' bind: rNumVars bind: rDst bind: 8 bind: 6 bind: 23)
        with: (self instr: 'ori' bind: rDst bind: rDst bind: 2r1111)  ]

}

MakeIndexedHeader
{
  [ :rNumVars :rDst | OrderedCollection 
        with: (self instr: 'rlwinm' bind: rNumVars bind: rDst bind: 8 bind: 6 bind: 23)
        with: (self instr: 'ori' bind: rDst bind: rDst bind: 2r1111)
        with: (self instr: 'oris' bind: rDst bind: rDst bind: 16r4000)  ]

}

MakeIndexedPartHeader
{
  [ :rNumVars :rDst | OrderedCollection 
        with: (self instr: 'rlwinm' bind: rNumVars bind: rDst bind: 8 bind: 6 bind: 23)
        with: (self instr: 'ori' bind: rDst bind: rDst bind: 2r1111)
        with: (self instr: 'oris' bind: rDst bind: rDst bind: 16r6000)  ]

}

MakeZByteHeader
{
  [ :rNumVars :rDst | OrderedCollection 
        with: (self instr: 'rlwinm' bind: rNumVars bind: rDst bind: 8 bind: 6 bind: 23)
        with: (self instr: 'ori' bind: rDst bind: rDst bind: 2r1111)
        with: (self instr: 'oris' bind: rDst bind: rDst bind: 16rC800)  ]

}


SizeOfHeader8
{
  [ :r | OrderedCollection 
        with: (self instr: 'rlwinm' bind: r bind: r bind: 16 bind: 24 bind: 31) ]
}


SizeOfHeader
{
  [ :r | OrderedCollection 
        with: (self instr: 'rlwinm' bind: r bind: r bind: 24 bind: 14 bind: 31) ]
}


Trap
{
  [ OrderedCollection 
        with: (self instr: 'tw' bind: 31 bind: 0 bind: 0) ]
}
   
PrintConsole
{
  [ :rRcv | OrderedCollection new
        add: (self instr: 'ori' bind: 0 bind: 20 bind: 0); "save r0"
        add: (self instr: 'ori' bind: 3 bind: 21 bind: 0); "save r3"
        add: (self instr: 'ori' bind: 4 bind: 22 bind: 0); "save r4"
        add: (self instr: 'ori' bind: 5 bind: 23 bind: 0); "save r5"

        add: (self instr: 'addi' bind: 0 bind: 0 bind: 4); "r0 := 4"
        add: (self instr: 'addi' bind: 3 bind: 0 bind: 1); "r3 := 1"
        add: (self instr: 'addi' bind: 4 bind: rRcv bind: 8); "buf"
        add: (self instr: 'lwz' bind: 5 bind: rRcv bind: 0);
        add: (self instr: 'rlwinm' bind: 5 bind: 5 bind: 24 bind: 14 bind: 31);

        add: (self instr: 'sc' bind: 0);

        add: (self instr: 'ori' bind: 20 bind: 0 bind: 0);
        add: (self instr: 'ori' bind: 21 bind: 3 bind: 0);
        add: (self instr: 'ori' bind: 22 bind: 4 bind: 0);
        add: (self instr: 'ori' bind: 23 bind: 5 bind: 0);
        yourself ]

}

