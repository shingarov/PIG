PopR
{
  [ :r | OrderedCollection 
        with: (self instr: #addi bind: 18 bind: 18 bind: -4)
        with: (self instr: #lw bind: 18 bind: r bind: 0)]
}

    
RREqualP
{
  [ :rA :rB :to | OrderedCollection 
        with: (self instr: #instr_xor bind: rA bind: rB bind: to bind: 0)
        with: (self instr: #sltiu bind: to bind: to bind: 1)]
}
   

PushR
{
  [ :r | OrderedCollection 
        with: (self instr: #addi bind: 18 bind: 18 bind: 4)
        with: (self instr: #sw bind: 18 bind: r bind: 0)]
}

    
PushRIndirect
{
  [ :r :offset | OrderedCollection 
        with: (self instr: #addi bind: 18 bind: 18 bind: 4)
        with: (self instr: #lwz bind: r bind: 20 bind: offset) 
        with: (self instr: #sw bind: 18 bind: 20 bind: 0)]
}

    
NoteIndex
{
  [ :i | OrderedCollection 
        with: (self instr: #addi bind: 0 bind: 19 bind: i)]
}

   
LoadByteIndexed
{
  [ :rDest :rBase :offset | OrderedCollection 
        with: (self instr: #lb bind: rBase bind: rDest bind: offset)]
}


LoadIndexed
{
  [ :rDest :rBase :offset | OrderedCollection 
        with: (self instr: #lw bind: rBase bind: rDest bind: offset)]
}


LoadIndexedRor0
{
  [ :rDest :rBase :rOffset | OrderedCollection 
        with: (self instr: #add bind: rBase bind: rOffset bind: 20)
        with: (self instr: #lw bind: 20 bind: rDest bind: 0)]
}


AddRRConst
{
  [ :from :to :const | OrderedCollection 
        with: (self instr: #addi bind: from bind: to bind: const)]
}


MulRRConst
{
  [ :from :to :const | OrderedCollection 
        with: (self instr: #addi bind: 0 bind: 20 bind: const)
        with: (self instr: #multu bind: from bind: 20 bind: 0 bind: 0)
        with: (self instr: #mflo  bind: 0 bind: 0 bind: to bind: 0)]
}


MulRR
{
  [ :rDst :a :b | OrderedCollection 
        with: (self instr: #multu bind: a bind: b bind: 0 bind: 0)
        with: (self instr: #mflo  bind: 0 bind: 0 bind: to bind: 0)]
}


AddRR
{
  [ :rDest :rSrcA :rSrcB | OrderedCollection 
        with: (self instr: #add bind: rSrcA bind: rSrcB bind: rDest bind: 0)]
}


SubRR
{
  [ :rDest :rSrcA :rSrcB | OrderedCollection 
        with: (self instr: #subu bind: rSrcA bind: rSrcB bind: rDest bind: 0)]
}


MovRR
{
  [ :from :to | OrderedCollection 
        with: (self instr: #add bind: from bind: 0 bind: to bind: 0)]
}


MovRLR
{
  [ :rSrc | OrderedCollection 
        with: (self instr: #add bind: rSrc bind: 0 bind: 31 bind: 0)]
}


MovLRR
{
  [ :rDest | OrderedCollection 
        with: (self instr: #add bind: 31 bind: 0 bind: rDest bind: 0)]
}


StoreIndexed
{
  [ :rSrc :rBase :off | OrderedCollection 
        with: (self instr: #sw bind: rSrc bind: rBase bind: offset)]
}


StoreByteIndexed
{
  [ :rSrc :rBase :off | OrderedCollection 
        with: (self instr: #sb bind: rSrc bind: rBase bind: offset)]
}


ShiftLeft2
{
  [ :rSrc :rDest | OrderedCollection 
        with: (self instr: #sll bind: rSrc bind: 0 bind: rDest bind: 2)]
}


LoadImm32
{
  [ :r :int | OrderedCollection 
        with: (self instr: #lui bind: r bind: (int >> 16 decodeSignedWidth: 16))
        with: (self instr: #ori bind: r bind: r bind: ((int bitAnd: 16rFFFF) decodeSignedWidth: 16)) ]
}


JumpImm32
{
  [ :int | OrderedCollection 
        with: (self instr: #lui bind: 20 bind: (int >> 16 decodeSignedWidth: 16))
        with: (self instr: #ori bind: 20 bind: 20 bind: ((int bitAnd: 16rFFFF) decodeSignedWidth: 16))
        with: (self instr: #jr bind: 20 bind: 0 bind: 0 bind: 0)
        with: (self instr: #sll bind: 0 bind: 0 bind: 0 bind: 0)]
}


JumpImm32IfNE
{
  [ :addr | OrderedCollection 
        with: (self instr: #sll bind: 0 bind: 0 bind: 0 bind: 0)]
}

JumpRelIfLE
{
  [ :offset | OrderedCollection 
        with: (self instr: #sll bind: 0 bind: 0 bind: 0 bind: 0)]
}

JumpRelIfEQ
{
  [ :offset | OrderedCollection 
        with: (self instr: #sll bind: 0 bind: 0 bind: 0 bind: 0)]
}


JumpRelIfTagNE
{
  [ :rWhereTagIs :compareTo :offset | OrderedCollection
        with: (self instr: #sll bind: 0 bind: 0 bind: 0 bind: 0)]
}


JumpRifEQ
{
  [ :r | OrderedCollection 
        with: (self instr: #sll bind: 0 bind: 0 bind: 0 bind: 0)]
}

JumpRifNE
{
  [ :r | OrderedCollection 
        with: (self instr: #sll bind: 0 bind: 0 bind: 0 bind: 0)]
}

JumpImm32andLink
{
  [ :int | OrderedCollection 
        with: (self instr: #lui bind: 20 bind: (int >> 16 decodeSignedWidth: 16))
        with: (self instr: #ori bind: 20 bind: 20 bind: ((int bitAnd: 16rFFFF) decodeSignedWidth: 16))
        with: (self instr: #jalr bind: 20 bind: 0 bind: 0 bind: 0)
        with: (self instr: #sll bind: 0 bind: 0 bind: 0 bind: 0)]
}

JumpRandLink
{
  [ :r | OrderedCollection 
        with: (self instr: #sll bind: 0 bind: 0 bind: 0 bind: 0)]
}

JumpR
{
  [ :r | OrderedCollection 
        with: (self instr: #sll bind: 0 bind: 0 bind: 0 bind: 0)]
}


JumpRifZ
{
  [ :r | OrderedCollection 
        with: (self instr: #sll bind: 0 bind: 0 bind: 0 bind: 0)]
}


SignBit
{
  [ :rSrc :rDst | OrderedCollection 
        with: (self instr: #sll bind: 0 bind: 0 bind: 0 bind: 0)]
}


EncodeChar
{
  [ :rSrc :rDst | OrderedCollection 
        with: (self instr: #sll bind: 0 bind: 0 bind: 0 bind: 0)]
}


DecodeChar
{
  [ :rSrc :rDst | OrderedCollection 
        with: (self instr: #sll bind: 0 bind: 0 bind: 0 bind: 0)]
}


EncodeSI
{
  [ :rSrc :rDst | OrderedCollection 
        with: (self instr: #sll bind: 0 bind: 0 bind: 0 bind: 0)]
}


DecodeSI
{
  [ :rSrc :rDst | OrderedCollection 
        with: (self instr: #sll bind: 0 bind: 0 bind: 0 bind: 0)]
}


SlotSIOffsetToByteOffset
{
  [ :rSrc :rDst | OrderedCollection 
        with: (self instr: #sll bind: 0 bind: 0 bind: 0 bind: 0)]
}


GetTag
{
  [ :rSrc :rDst | OrderedCollection 
        with: (self instr: #sll bind: 0 bind: 0 bind: 0 bind: 0)]
}


StripTag
{
  [ :rSrc :rDst | OrderedCollection 
        with: (self instr: #sll bind: 0 bind: 0 bind: 0 bind: 0)]
}


MarkSuccess
{
  [ OrderedCollection 

        with: (self instr: #sll bind: 0 bind: 0 bind: 0 bind: 0)]
}


MarkFail
{
  [ OrderedCollection 
        with: (self instr: #sll bind: 0 bind: 0 bind: 0 bind: 0)]
}


Return
{
  [ OrderedCollection 
        with: (self instr: #sll bind: 0 bind: 0 bind: 0 bind: 0)]
}


ReturnIfEQ
{
  [ OrderedCollection 
        with: (self instr: #sll bind: 0 bind: 0 bind: 0 bind: 0)]
}


RoundUpTo16
{
  [ :rSrc :rDst | OrderedCollection 

        with: (self instr: #sll bind: 0 bind: 0 bind: 0 bind: 0)]
}


AttachContextTag
{
  [ :r | OrderedCollection 

        with: (self instr: #sll bind: 0 bind: 0 bind: 0 bind: 0)]
}

MakeOopHeader
{
  [ :rNumVars :rDst | OrderedCollection 

        with: (self instr: #sll bind: 0 bind: 0 bind: 0 bind: 0)]
}

SizeOfHeader
{
  [ :r | OrderedCollection 

        with: (self instr: #sll bind: 0 bind: 0 bind: 0 bind: 0)]
}


Trap
{
  [ OrderedCollection 
        with: (self instr: #sll bind: 0 bind: 0 bind: 0 bind: 0)]
}
   
